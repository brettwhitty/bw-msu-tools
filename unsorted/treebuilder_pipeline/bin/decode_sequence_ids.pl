#! /usr/bin/perl

# decode_sequence_ids.pl

# 6 August 2009
# Kevin Childs

# This script decodes the sequence names in a phyloxml file.  
# It uses the decoder file that was generated by the parse_orthomcl_results.pl 
# script.  Additionally, this script will add an accession tag in the xml file 
# that will be used for generating a url to the annotation report page for the 
# sequence, a taxonomy tag with code and scientific_name child tags will also 
# be added to allow the species name to be displayed within Archaeopteryx.

use Getopt::Std;
use XML::Twig;
use Bio::SeqIO;

use strict;

my $usage = "\n$0 -i input_xml -d decoder_file\n\n";

our ( $opt_i, $opt_d, $opt_h );
getopts("i:d:h") or die usage();

if ($opt_h) {
    print $usage;
    exit;
}

my $input_xml = $opt_i;
my $decoder_file = $opt_d;

if (   !defined($input_xml)
       || !( -e $input_xml )
       || !defined($decoder_file)
       || !(-e $decoder_file)) {
    die "\nMissing or invalid input values.\n$input_xml\n$decoder_file\n" . $usage;
}

my $short_xml_file_name;
if ($input_xml =~ /([\w\.]+)\.xml$/) {
    $short_xml_file_name = $1;
}
else {
    die "\nUnable to parse cluster name out of file name.\nX$input_xml" . "X\n\n";
}

my %decoder;

open DECODER, "$decoder_file" || die "\nUnable to open decoder file, $decoder_file, for reading.\n\n";
while (my $line = <DECODER>) {
    chomp $line;
    my $cluster_found = 0;
    if ($line =~ /^#$short_xml_file_name$/) {
        # This is our cluster.
        while ($line = <DECODER>) {
            chomp $line;
            my @elems = split "\t", $line;
            if ($elems[0] =~ /\D/) {
                # This is something beside a number.  We're finished.
                $cluster_found = 1;
                last;
            }
            $decoder{$elems[0]} = $elems[1];
        }
    }
    if ($cluster_found == 1) {
        last;
    }
}

my $twig = XML::Twig->new( twig_handlers => { #sequence => \&decode_seq_name, 
                          clade => \&add_taxonomy_data },
               PrettyPrint => 'indented');
$twig->parsefile($input_xml);

open( FH, ">$input_xml") or die "\nCannot open $input_xml for reading:\n $!\n\n";
$twig->print( \*FH);
$twig->purge();

exit;

sub decode_seq_name {
    my ($twig, $seq_tag) = @_;

    my $codename = $seq_tag->first_child('name')->text();
    my $name = $decoder{$codename};
    $seq_tag->first_child('name')->set_text($name);
    my $accession= new XML::Twig::Elt('accession', $name);   # create the element
    $accession->paste('last_child', $seq_tag);
    $accession->set_att('source' => 'SGR');
    #$twig->flush();
}

sub add_taxonomy_data {
    my ($twig, $clade_tag) = @_;

    my $seq_tag = $clade_tag->first_child('sequence');
    if (!defined($seq_tag)) {
    # The problem with this xml schema is that there are 'clade' tags that do not
    # contain sequence tags.
    return;
    }
    my $codename = $seq_tag->first_child('name')->text();
    #print "codename: $codename\n";
    my $name = $decoder{$codename};

    if (!defined($name)) {
    die "\nThe codename, $codename, was not defined within the decoder hash.\n$input_xml\n\n";
    }

    $seq_tag->first_child('name')->set_text($name);
    my $accession = new XML::Twig::Elt('accession', $name);   # create an accession element
    $accession->paste('last_child', $seq_tag);
    $accession->set_att('source' => 'SGR');

    my $taxonomy = new XML::Twig::Elt('taxonomy');   # create a taxonomy element
    $taxonomy->paste('last_child', $clade_tag);

    my ($bfgr_code, $species) = get_species_info($name);
#    my ($bfgr_code, $species) = ('', '');

    my $tax_code = new XML::Twig::Elt('code', $bfgr_code);  # create a code element
    $tax_code->paste('first_child', $taxonomy);
    my $scientific_name = new XML::Twig::Elt('scientific_name', $species);  # create a code element
    $scientific_name->paste('last_child', $taxonomy);

}

sub get_species_info {
    my ($gene_id) = @_;
    
    ## use gene id to find taxon_id and species_name
    my $taxon_id;
    my $genus_species;

    print $gene_id."\n";

    ## 14 complete plant genomes
    if ($gene_id =~ /^PGSC0/) {
        $taxon_id = '172790';
        $genus_species = 'Solanum phureja';
    } elsif ($gene_id =~ /^POPTR/) {
        $taxon_id = '3694';
        $genus_species = 'Populus trichocarpa';
    } elsif ($gene_id =~ /^jgi\|Phypa/) {
        $taxon_id = '3218';
        $genus_species = 'Physcomitrella patens';
    } elsif ($gene_id =~ /^Sb/) {
        $taxon_id = '4558';
        $genus_species = 'Sorghum bicolor';
    } elsif ($gene_id =~ /^jgi\|Selmo/) {
        $taxon_id = '88036';
        $genus_species = 'Selaginella moellendorffii';
    } elsif ($gene_id =~ /^Au9.Cre/) {
        $taxon_id = '3055';
        $genus_species = 'Chlamydomonas reinhardtii';
    } elsif ($gene_id =~ /^evm.TU.supercontig_|^evm.TU.contig_/) {
        $taxon_id = '3649';
        $genus_species = 'Carica papaya';
    } elsif ($gene_id =~ /^LOC_Os/) {
        $taxon_id = '39946';
        $genus_species = 'Oryza sativa';
    } elsif ($gene_id =~ /^GSVIV/) {
        $taxon_id = '29760';
        $genus_species = 'Vitis vinifera';
    } elsif ($gene_id =~ /^Bradi/) {
        $taxon_id = '15368';
        $genus_species = 'Brachypodium distachyon';
    } elsif ($gene_id =~ /^AT/) {
        $taxon_id = '3702';
        $genus_species = 'Arabidopsis thaliana';
    } elsif ($gene_id =~ /^GRMZM|^AC\d+|^AF\d+|^AY\d+|^EF\d+/ ) {
        $taxon_id = '4577';
        $genus_species = 'Zea mays';
    } elsif ($gene_id =~ /^Cucsa/) {
        $taxon_id = '3659';
        $genus_species = 'Cucumis sativus';
    } elsif ($gene_id =~ /^\d+/) {
        $taxon_id = '3847';
        $genus_species = 'Glycine max';
    } else {
        $taxon_id = '';
        $genus_species = 'unknown';
    }

    return ($taxon_id, $genus_species);
}

